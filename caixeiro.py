# -*- coding: utf-8 -*-
"""caixeiro.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-oiEmzPaaLuzvjvvCWEbXMb-W44j_4PC
"""

!pip install deap

import random
import numpy as np
from deap import base, creator, tools, algorithms

cities = {
    "Cesky Krumlov": (48.8127, 14.3178),
    "Hallstatt": (47.5622, 13.6493),
    "Positano": (40.6281, 14.484),
    "Annecy": (45.8992, 6.1294),
    "Bruges": (51.2093, 3.2247),
    "Zermatt": (46.0207, 7.7491),
    "Sintra": (38.8029, -9.3817),
    "Cinque Terre": (44.1481, 9.6544),
    "Santorini": (36.3932, 25.4615),
    "Delft": (52.0116, 4.3571),
    "Colmar": (48.0794, 7.3585),
    "Varsóvia": (52.2297, 21.0122)
}

# Criação do tipo Fitness (minimização)
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
# Criação do tipo indivíduo (cromossomo)
creator.create("Individual", list, fitness=creator.FitnessMin)

toolbox = base.Toolbox()

# Inicialização de um indivíduo (rota aleatória)
toolbox.register("indices", random.sample, range(len(cities)), len(cities))
toolbox.register("individual", tools.initIterate, creator.Individual, toolbox.indices)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)

# Função de avaliação (distância total da rota)
def evalTSP(individual):
    distance = 0
    for i in range(len(individual)):
        city1 = cities[list(cities.keys())[individual[i]]]
        city2 = cities[list(cities.keys())[individual[i - 1]]]
        distance += np.sqrt((city1[0] - city2[0])**2 + (city1[1] - city2[1])**2)
    return distance,

# Registro de operadores genéticos
toolbox.register("mate", tools.cxOrdered)
toolbox.register("mutate", tools.mutShuffleIndexes, indpb=0.05)
toolbox.register("select", tools.selTournament, tournsize=3)
toolbox.register("evaluate", evalTSP)

def main():
    random.seed(42)
    pop = toolbox.population(n=300)
    hof = tools.HallOfFame(1)
    stats = tools.Statistics(lambda ind: ind.fitness.values)
    stats.register("avg", np.mean)
    stats.register("std", np.std)
    stats.register("min", np.min)
    stats.register("max", np.max)

    algorithms.eaSimple(pop, toolbox, cxpb=0.8, mutpb=0.2, ngen=500, stats=stats, halloffame=hof, verbose=True)

    best_route = hof[0]
    print("Melhor rota encontrada:", best_route)
    print("Distância da melhor rota:", evalTSP(best_route)[0])

if __name__ == "__main__":
    main()